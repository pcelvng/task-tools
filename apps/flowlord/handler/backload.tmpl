<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowlord: Backload</title>
    <link rel="icon" type="image/svg+xml" href="{{if .isLocal}}./static{{else}}/static{{end}}/favicon.svg">
    <link rel="stylesheet" href="{{if .isLocal}}./static{{else}}/static{{end}}/style.css">
</head>
<body>
    {{template "header" .}}
    <div class="container">
        <div class="content">
            <div class="backload-form">
                <div class="info-grid">
                    <!-- Task Selection Section -->
                    <div class="info-card">
                        <h3>Task Selection</h3>
                        <div class="form-group">
                            <label for="taskSearch">Task</label>
                            <div class="search-select-container">
                                <input type="text" id="taskSearch" class="form-control" placeholder="Type to search or click to browse..." autocomplete="off">
                                <div id="taskDropdown" class="search-dropdown"></div>
                            </div>
                            <input type="hidden" id="taskSelect" value="">
                        </div>
                        <div class="form-group">
                            <label for="jobSelect">Job</label>
                            <select id="jobSelect" class="form-control" disabled>
                                <option value="">Select a job...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="workflowFilter">Filter by Workflow</label>
                            <select id="workflowFilter" class="form-control">
                                <option value="">All Workflows</option>
                                {{range $file, $phases := .PhasesByWorkflow}}
                                <option value="{{$file}}">{{$file}}</option>
                                {{end}}
                            </select>
                        </div>
                    </div>

                    <!-- Date Section -->
                    <div class="info-card">
                        <h3>Date</h3>
                        <div class="form-group">
                            <label>Date Mode</label>
                            <div class="toggle-group">
                                <button type="button" class="toggle-btn active" data-mode="single">At</button>
                                <button type="button" class="toggle-btn" data-mode="range">Range</button>
                            </div>
                        </div>
                        <div id="singleDateInput">
                            <div class="form-group">
                                <label for="atDate">Date</label>
                                <input type="date" id="atDate" class="form-control">
                            </div>
                        </div>
                        <div id="dateRangeInputs" style="display: none;">
                            <div class="form-group">
                                <label for="fromDate">From</label>
                                <input type="date" id="fromDate" class="form-control">
                            </div>
                            <div class="form-group">
                                <label for="toDate">To</label>
                                <input type="date" id="toDate" class="form-control">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="bySelect">By</label>
                            <select id="bySelect" class="form-control">
                                <option value="hour">Hour</option>
                                <option value="day" selected>Day</option>
                                <option value="week">Week</option>
                                <option value="month">Month</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Meta Fields Section -->
                <div class="info-card" id="metaSection" style="display: none;">
                    <h3>Meta Fields</h3>
                    <p class="meta-hint">The selected task template requires the following meta fields:</p>
                    <div id="metaFieldsContainer"></div>
                </div>

                <!-- Meta File Section -->
                <div class="info-card" id="metaFileSection" style="display: none;">
                    <h3>Meta File</h3>
                    <p class="meta-hint">Provide a path to a JSON/CSV file for meta data (each row creates a task):</p>
                    <div class="form-group">
                        <label for="metaFileInput">Meta File Path</label>
                        <input type="text" id="metaFileInput" class="form-control" placeholder="s3://bucket/path/to/meta.json">
                    </div>
                </div>

                <!-- Template Info Section -->
                <div class="info-card template-section" id="templateSection" style="display: none;">
                    <h3>Template Details</h3>
                    <div class="template-info">
                        <div class="form-group">
                            <label>Template</label>
                            <div class="template-display" id="templateDisplay"></div>
                        </div>
                        <div class="form-group">
                            <label>Rule</label>
                            <div class="template-display" id="ruleDisplay"></div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button type="button" id="previewBtn" class="btn btn-primary" disabled>
                        Preview (Dry Run)
                    </button>
                    <button type="button" id="executeBtn" class="btn btn-success" disabled style="display: none;">
                        Execute Backload
                    </button>
                    <button type="button" id="resetBtn" class="btn btn-secondary">
                        Reset
                    </button>
                </div>

                <!-- Request Body Display -->
                <div class="info-card" id="requestBodySection" style="display: none;">
                    <h3>Request Body</h3>
                    <pre class="request-body-display" id="requestBodyDisplay"></pre>
                </div>

                <!-- Preview Results Section -->
                <div class="info-card" id="previewSection" style="display: none;">
                    <h3>Preview Results</h3>
                    <div id="previewStatus" class="preview-status"></div>
                    <div class="table-container">
                        <table id="previewTable">
                            <thead>
                                <tr>
                                    <th class="num-column">#</th>
                                    <th class="type-column">Type</th>
                                    <th class="job-column">Job</th>
                                    <th class="info-column">Info</th>
                                    <th class="meta-column">Meta</th>
                                </tr>
                            </thead>
                            <tbody id="previewTableBody">
                            </tbody>
                        </table>
                    </div>
                    <div id="previewCount" class="stats"></div>
                </div>

                <!-- Execution Result Section -->
                <div class="info-card" id="executionSection" style="display: none;">
                    <h3>Execution Result</h3>
                    <div id="executionStatus" class="execution-status"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Store phase data from server - flat list with workflow info
        const allPhases = {{.PhasesJSON}};

        // Build unique task list
        function getUniqueTasks(workflowFilter = '') {
            const taskSet = new Set();
            allPhases.forEach(p => {
                if (!workflowFilter || p.workflow === workflowFilter) {
                    taskSet.add(p.task);
                }
            });
            return Array.from(taskSet).sort();
        }

        // DOM elements
        const taskSearch = document.getElementById('taskSearch');
        const taskDropdown = document.getElementById('taskDropdown');
        const taskSelect = document.getElementById('taskSelect');
        const workflowFilter = document.getElementById('workflowFilter');
        const jobSelect = document.getElementById('jobSelect');
        const templateSection = document.getElementById('templateSection');
        const templateDisplay = document.getElementById('templateDisplay');
        const ruleDisplay = document.getElementById('ruleDisplay');
        const metaSection = document.getElementById('metaSection');
        const metaFieldsContainer = document.getElementById('metaFieldsContainer');
        const metaFileSection = document.getElementById('metaFileSection');
        const metaFileInput = document.getElementById('metaFileInput');
        const previewBtn = document.getElementById('previewBtn');
        const executeBtn = document.getElementById('executeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const previewSection = document.getElementById('previewSection');
        const previewStatus = document.getElementById('previewStatus');
        const previewTableBody = document.getElementById('previewTableBody');
        const previewCount = document.getElementById('previewCount');
        const executionSection = document.getElementById('executionSection');
        const executionStatus = document.getElementById('executionStatus');

        // Current selection state
        let currentPhase = null;
        let previewTasks = [];

        // Date mode toggle
        document.querySelectorAll('.toggle-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                const dateRangeInputs = document.getElementById('dateRangeInputs');
                const singleDateInput = document.getElementById('singleDateInput');
                if (this.dataset.mode === 'range') {
                    dateRangeInputs.style.display = 'block';
                    singleDateInput.style.display = 'none';
                } else {
                    dateRangeInputs.style.display = 'none';
                    singleDateInput.style.display = 'block';
                }
                updatePreviewButton();
            });
        });

        // Show task dropdown with optional filtering
        function showTaskDropdown(query = '') {
            const workflow = workflowFilter.value;
            const tasks = getUniqueTasks(workflow);
            const matches = query 
                ? tasks.filter(t => t.toLowerCase().includes(query.toLowerCase()))
                : tasks;
            
            if (matches.length > 0) {
                taskDropdown.innerHTML = matches.map(task => 
                    `<div class="search-dropdown-item" data-task="${escapeHtml(task)}">${query ? highlightMatch(task, query) : escapeHtml(task)}</div>`
                ).join('');
                taskDropdown.style.display = 'block';
            } else {
                taskDropdown.innerHTML = '<div class="search-dropdown-empty">No matching tasks</div>';
                taskDropdown.style.display = 'block';
            }
        }

        // Task search functionality
        let searchTimeout;
        taskSearch.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            searchTimeout = setTimeout(() => {
                showTaskDropdown(query);
            }, 100);
        });

        // Show full dropdown on focus and clear existing value
        taskSearch.addEventListener('focus', function() {
            this.value = '';
            taskSelect.value = '';
            showTaskDropdown('');
        });

        // Highlight matching text
        function highlightMatch(text, query) {
            const idx = text.toLowerCase().indexOf(query.toLowerCase());
            if (idx === -1) return escapeHtml(text);
            return escapeHtml(text.slice(0, idx)) + '<strong>' + escapeHtml(text.slice(idx, idx + query.length)) + '</strong>' + escapeHtml(text.slice(idx + query.length));
        }

        // Task dropdown item click
        taskDropdown.addEventListener('click', function(e) {
            const item = e.target.closest('.search-dropdown-item');
            if (item) {
                const task = item.dataset.task;
                taskSearch.value = task;
                taskSelect.value = task;
                taskDropdown.style.display = 'none';
                onTaskSelected(task);
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!taskSearch.contains(e.target) && !taskDropdown.contains(e.target)) {
                taskDropdown.style.display = 'none';
            }
        });

        // Workflow filter handler
        workflowFilter.addEventListener('change', function() {
            // Reset task selection when filter changes
            taskSearch.value = '';
            taskSelect.value = '';
            jobSelect.innerHTML = '<option value="">Select a job...</option>';
            jobSelect.disabled = true;
            hideTemplateInfo();
            updatePreviewButton();
        });

        // Handle task selection
        function onTaskSelected(task) {
            const workflow = workflowFilter.value;
            jobSelect.innerHTML = '<option value="">Select a job...</option>';
            jobSelect.disabled = true;
            hideTemplateInfo();
            
            // Find phases matching this task (optionally filtered by workflow)
            const phases = allPhases.filter(p => 
                p.task === task && (!workflow || p.workflow === workflow)
            );
            const jobs = [...new Set(phases.map(p => p.job).filter(j => j))];
            
            if (jobs.length > 0) {
                jobs.sort().forEach(job => {
                    const option = document.createElement('option');
                    option.value = job;
                    option.textContent = job;
                    jobSelect.appendChild(option);
                });
                jobSelect.disabled = false;
            } else {
                // No job needed, use first phase
                const phase = phases[0];
                if (phase) {
                    showTemplateInfo(phase);
                }
            }
            updatePreviewButton();
        }

        // Job selection handler
        jobSelect.addEventListener('change', function() {
            const task = taskSelect.value;
            const job = this.value;
            const workflow = workflowFilter.value;
            
            const phase = allPhases.find(p => 
                p.task === task && 
                (p.job === job || (!job && !p.job)) &&
                (!workflow || p.workflow === workflow)
            );
            if (phase) {
                showTemplateInfo(phase);
            }
            updatePreviewButton();
        });

        // Format rule string for better readability (one param per line)
        function formatRule(str) {
            if (!str) return '(no rule)';
            // Split on & and join with newlines for readability
            return str.split('&').join('\n');
        }

        // Show template information and detect meta fields
        function showTemplateInfo(phase) {
            currentPhase = phase;
            templateSection.style.display = 'block';
            templateDisplay.textContent = phase.template || '(no template)';
            ruleDisplay.textContent = formatRule(phase.rule);
            
            // Parse template for meta fields
            const metaRegex = /\{meta:(\w+)\}/g;
            const metaKeys = [];
            let match;
            while ((match = metaRegex.exec(phase.template)) !== null) {
                if (!metaKeys.includes(match[1])) {
                    metaKeys.push(match[1]);
                }
            }
            
            // Check if rule has meta-file
            const hasMetaFile = phase.rule && phase.rule.includes('meta-file=');
            const hasMeta = phase.rule && phase.rule.includes('meta=');
            
            // Show meta fields section if template has meta placeholders and no meta-file in rule
            if (metaKeys.length > 0 && !hasMetaFile) {
                metaSection.style.display = 'block';
                metaFieldsContainer.innerHTML = '';
                
                metaKeys.forEach(key => {
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';
                    formGroup.innerHTML = `
                        <label for="meta_${key}">{meta:${key}}</label>
                        <input type="text" id="meta_${key}" class="form-control meta-input" 
                               data-meta-key="${key}" placeholder="Enter values (comma-separated for multiple)">
                        <small class="form-hint">Comma-separated values create multiple tasks</small>
                    `;
                    metaFieldsContainer.appendChild(formGroup);
                });
            } else {
                metaSection.style.display = 'none';
            }
            
            // Show meta file section if rule has meta-file or no meta defined
            if (hasMetaFile) {
                metaFileSection.style.display = 'block';
                // Extract default meta-file path from rule
                const metaFileMatch = phase.rule.match(/meta-file=([^&]+)/);
                if (metaFileMatch) {
                    metaFileInput.value = metaFileMatch[1];
                }
            } else {
                metaFileSection.style.display = 'none';
                metaFileInput.value = '';
            }
        }

        // Hide template information
        function hideTemplateInfo() {
            currentPhase = null;
            templateSection.style.display = 'none';
            metaSection.style.display = 'none';
            metaFileSection.style.display = 'none';
            previewSection.style.display = 'none';
            executionSection.style.display = 'none';
            executeBtn.style.display = 'none';
            document.getElementById('requestBodySection').style.display = 'none';
            
            // Clear meta field values
            metaFieldsContainer.innerHTML = '';
            metaFileInput.value = '';
        }

        // Get current date mode from toggle
        function getDateMode() {
            const activeBtn = document.querySelector('.toggle-btn.active');
            return activeBtn ? activeBtn.dataset.mode : 'range';
        }

        // Update preview button state
        function updatePreviewButton() {
            const task = taskSelect.value;
            const dateMode = getDateMode();
            let hasDate = false;
            
            if (dateMode === 'range') {
                const from = document.getElementById('fromDate').value;
                const to = document.getElementById('toDate').value;
                hasDate = from || to; // At least one date
            } else {
                hasDate = document.getElementById('atDate').value;
            }
            
            previewBtn.disabled = !task || !hasDate;
        }

        // Add date input listeners
        ['fromDate', 'toDate', 'atDate'].forEach(id => {
            document.getElementById(id).addEventListener('change', updatePreviewButton);
        });

        // Preview button handler
        previewBtn.addEventListener('click', async function() {
            const request = buildRequest(false);
            const requestBody = JSON.stringify(request, null, 2);
            
            // Show request body
            document.getElementById('requestBodySection').style.display = 'block';
            document.getElementById('requestBodyDisplay').textContent = requestBody;
            
            previewBtn.disabled = true;
            previewBtn.textContent = 'Loading...';
            
            try {
                const response = await fetch('{{if .isLocal}}/backload{{else}}/backload{{end}}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(request),
                });
                
                const responseText = await response.text();
                let data;
                
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    // Response is plain text (error message)
                    throw new Error(responseText || 'Request failed');
                }
                
                if (!response.ok) {
                    throw new Error(data.Status || responseText || 'Request failed');
                }
                
                previewTasks = data.Tasks || [];
                showPreviewResults(data);
                
            } catch (error) {
                previewStatus.className = 'preview-status error';
                previewStatus.textContent = 'Error: ' + error.message;
                previewSection.style.display = 'block';
                previewTableBody.innerHTML = '';
                previewCount.textContent = '';
                executeBtn.style.display = 'none';
            } finally {
                previewBtn.disabled = false;
                previewBtn.textContent = 'Preview (Dry Run)';
            }
        });

        // Execute button handler
        executeBtn.addEventListener('click', async function() {
            if (!confirm('Are you sure you want to execute this backload? This will create ' + previewTasks.length + ' tasks.')) {
                return;
            }
            
            const request = buildRequest(true);
            
            // Update request body display
            document.getElementById('requestBodyDisplay').textContent = JSON.stringify(request, null, 2);
            
            executeBtn.disabled = true;
            executeBtn.textContent = 'Executing...';
            
            try {
                const response = await fetch('{{if .isLocal}}/backload{{else}}/backload{{end}}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(request),
                });
                
                const responseText = await response.text();
                let data;
                
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    throw new Error(responseText || 'Execution failed');
                }
                
                if (!response.ok) {
                    throw new Error(data.Status || responseText || 'Execution failed');
                }
                
                executionSection.style.display = 'block';
                executionStatus.className = 'execution-status success';
                executionStatus.innerHTML = `
                    <strong>Success!</strong><br>
                    ${escapeHtml(data.Status)}<br>
                    Created ${data.Count} tasks.
                `;
                executeBtn.style.display = 'none';
                
            } catch (error) {
                executionSection.style.display = 'block';
                executionStatus.className = 'execution-status error';
                executionStatus.textContent = 'Error: ' + error.message;
            } finally {
                executeBtn.disabled = false;
                executeBtn.textContent = 'Execute Backload';
            }
        });

        // Reset button handler
        resetBtn.addEventListener('click', function() {
            taskSearch.value = '';
            taskSelect.value = '';
            workflowFilter.value = '';
            jobSelect.innerHTML = '<option value="">Select a job...</option>';
            jobSelect.disabled = true;
            document.getElementById('fromDate').value = '';
            document.getElementById('toDate').value = '';
            document.getElementById('atDate').value = '';
            document.getElementById('bySelect').value = 'day';
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.toggle-btn[data-mode="single"]').classList.add('active');
            document.getElementById('singleDateInput').style.display = 'block';
            document.getElementById('dateRangeInputs').style.display = 'none';
            hideTemplateInfo();
            updatePreviewButton();
        });

        // Build request object
        function buildRequest(execute) {
            const dateMode = getDateMode();
            const request = {
                Task: taskSelect.value,
            };
            
            // Only include Execute when true (omitzero)
            if (execute) {
                request.Execute = true;
            }
            
            // Only include Job if not empty
            const job = jobSelect.value;
            if (job) {
                request.Job = job;
            }
            
            // Only include By if not 'day' (default)
            const by = document.getElementById('bySelect').value;
            if (by && by !== 'day') {
                request.By = by;
            }
            
            if (dateMode === 'range') {
                const from = document.getElementById('fromDate').value;
                const to = document.getElementById('toDate').value;
                if (from) request.From = from;
                if (to) request.To = to;
            } else {
                const at = document.getElementById('atDate').value;
                if (at) request.At = at;
            }
            
            // Collect meta fields (only if visible and has values)
            if (metaSection.style.display !== 'none') {
                const metaInputs = document.querySelectorAll('.meta-input');
                if (metaInputs.length > 0) {
                    const meta = {};
                    metaInputs.forEach(input => {
                        const key = input.dataset.metaKey;
                        const value = input.value.trim();
                        if (value) {
                            meta[key] = value.split(',').map(v => v.trim());
                        }
                    });
                    if (Object.keys(meta).length > 0) {
                        request.meta = meta;
                    }
                }
            }
            
            // Collect meta file (only if visible and has value)
            if (metaFileSection.style.display !== 'none') {
                const metaFile = metaFileInput.value.trim();
                if (metaFile) {
                    request['meta-file'] = metaFile;
                }
            }
            
            return request;
        }

        // Show preview results
        function showPreviewResults(data) {
            previewSection.style.display = 'block';
            previewStatus.className = 'preview-status info';
            previewStatus.textContent = data.Status || 'Dry run complete';
            
            previewTableBody.innerHTML = '';
            
            if (data.Tasks && data.Tasks.length > 0) {
                data.Tasks.forEach((task, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="num-cell num-column">${index + 1}</td>
                        <td class="type-cell type-column">${escapeHtml(task.type || '')}</td>
                        <td class="job-cell job-column">${escapeHtml(task.job || '')}</td>
                        <td class="info-cell info-column expandable" title="Click to expand">${escapeHtml(task.info || '')}</td>
                        <td class="meta-cell meta-column expandable" title="Click to expand">${escapeHtml(task.meta || '')}</td>
                    `;
                    previewTableBody.appendChild(row);
                });
                
                previewCount.textContent = `Total tasks to be created: ${data.Count}`;
                executeBtn.style.display = 'inline-block';
                executeBtn.disabled = false;
            } else {
                previewTableBody.innerHTML = '<tr><td colspan="5" class="no-tasks">No tasks would be created</td></tr>';
                previewCount.textContent = '';
                executeBtn.style.display = 'none';
            }
            
            // Add expand/collapse functionality to cells
            document.querySelectorAll('#previewTableBody .expandable').forEach(cell => {
                cell.addEventListener('click', function() {
                    this.classList.toggle('expanded');
                });
            });
        }

        // Escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize date inputs with today's date
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('fromDate').value = today;
        document.getElementById('toDate').value = today;
        document.getElementById('atDate').value = today;
        updatePreviewButton();
    </script>
</body>
</html>
